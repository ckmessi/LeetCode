### 28. Implement strStr()

Implement strStr().

Returns the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.

* * *
经典的查找子串位置问题。   
使用KMP算法，虽然我一直……记不住。   

KMP算法主要是由两部分内容组成：求模式字符串的next数组、匹配。两者使用的核心思想是相同的，即当匹配失败时，如何移动字符以最大程度地避免重复匹配。

#### 一、匹配

对于匹配部分，可以这样理解，下标i指向搜索字符串s的当前位置，下标j指向模式字符串p的当前位置。位置都以0开始，即字符串第一个字符为s[0]。        
若s[i]==p[j]，则可以继续匹配，令i++,j++即可；    
否则，此时可分为两种可能性：    
若j==0，说明字符串p在j位置前不可能有前缀子串，需要执行的是i++，寻找下一个可能的匹配点i；    
若j>0，此时字符串p可能在j位置之前有子串满足p[0,k-1]==p[j-k,j-1]。目前匹配到这一步，肯定满足s[i-k,i-1]==p[j-k,j-1]，可推得s[i-k,i-1]==p[0,k-1]。这时候需要查找next数组，查看在next数组中next[j]的值（理论上这个值应该是k)，然后将j赋值为next[j]的值，即k，然后继续进行s[i]和s[j]的判断。

由此可知，我们求next数组时，next数组中next[i]保存的应该是模式字符串当前位置之前（即字符串p[0...i-1]）能够满足p[0,k-1]==p[i-k,i-1]最大的那个k。

### 二、求next数组

首先定义next数组的含义，next[i]表示的是在位置i之前能够满足p[0,k-1]==p[i-k,i-1]的最大的正整数k。k可以理解为长度，同时也等于满足位置k-1的位置下标加上1。        
特别的，next[0]==-1（其实是什么值都可以，因为之后会先判断j的位置，当j==0时不会去算next[j]的值）。。    

如何求解next数组，思路上与第一部分*匹配*是类似的。   
用下标i指向字符串p的当前位置（即需要求解next[i]值的当前位置i），下标j指向满足p[0,j-1]==p[i-j,i-1]的位置。由于next[0]不用求，初始时可令i==1,j==0。    

若p[i]==p[j]，则可以继续匹配，令i++,j++，next[i]==j（这里体现了next[i]实际上表示的是i-1位置的性质，而j是之前匹配位置+1正好是长度）即可；
若p[i]!=p[j]，此时可分为两种可能性：    
若j==0，说明j之前已经没有满足了，这时候next[i]=0，令i++即可；    
若j>0，在j之前可能有字符串满足p[0,k-1]==p[j-k,j-1]，这时候令j=k（即j=next[j]）继续尝试匹配即可。    


以上。


